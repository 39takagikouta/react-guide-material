159　（レンダリング）画面が更新されるまで
トリガー（stateの更新用関数or最初）
→レンダリング（関数コンポーネントの実行or最初）（親コンポーネントが際レンダリングされたら子も）
→コミットdom更新（react要素ツリーとdomツリーを比較し、差分だけを反映）

160
stateの比較処理はobject.isで検知
例外もあることを知っとく
注意点
配列やオブジェクトは同じ内容でもfalseになる　中身ではなく参照を比較している
参照が関連している　メモリ空間をイメージ
また、等価演算子と違いobject.isは型変換をしない

161
strictmode
2回ログが出る　rootコンポーネントを囲う
startは開発用　buildは本番用（こっちではログ1回）
開発時は使うべき

162。163
親がレンダリングしたら子コンポーネントも無駄にレンダリングする時がある
→React.memoでpropsのstateが更新されないと再レンダリングされない
オブジェクトの一部のプロパティの変更時のみ際レンダリングしたいときは第二引数を設定することもできる

164
関数もオブジェクトなので、propsで関数を渡していたらobject.isでfalseになる
memoが効かない→usecallbackで対処　使いまわしてくれる

166
処理の中でstateの更新をしていたらそれを依存配列に入れる

167
useMemo 値をメモ化（キャッシュ化（再計算せず保存、使いまわす））
react.memo コンポーネントをメモ化
これも依存配列ある
stateを使っている関数も
複雑な計算を担うやつはこれした方がいい
useMemo自体の処理は重いので、重い処理にだけ使う

168
コンカレントモード
処理の優先順位付けを行う
1useTransition
必要に迫られない限りは使わない
usememoやuseCallbackのパフォーマンスの最適化が先

169
2useDifferedValue
